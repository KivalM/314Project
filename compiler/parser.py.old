# an implementation of a recursive desscent parser for brainfuck
# https://en.wikipedia.org/wiki/Recursive_descent_parser
# https://www.geeksforgeeks.org/recursive-descent-parser/

# 1. <program> ::= <command> | <loop> | <command> <program> | <loop> <program>
# 2. <command> ::= ">" | "<" | "+" | "-" | "." | ","
# 3. <loop> ::= "[" <program> "]"

class BrainFuckNode:
    def __init__(self, value, children=[]):
        self.value = value
        self.children = children
        self.parent = None

    def add_child(self, child):
        child.parent = self
        self.children.append(child)

    def __str__(self):
        return self.value


class BrainfuckParser:
    def __init__(self, code):
        self.code = code
        self.ptr = 0

    def parse_program(self):
        nodes = []
        while self.ptr < len(self.code):
            char = self.code[self.ptr]

            if char in (">", "<", "+", "-", ".", ","):
                nodes.append(BrainFuckNode(self.parse_command()))
            elif char == "[":
                nodes.append(self.parse_loop())

        return BrainFuckNode("Program", nodes)

    def parse_command(self):
        char = self.code[self.ptr]
        self.ptr += 1
        return char

    def parse_loop(self):
        self.ptr += 1  # Skip the opening '['
        loop_nodes = self.parse_program()
        self.ptr += 1  # Skip the closing ']'
        return BrainFuckNode("Loop", loop_nodes.children)


# Example usage:
code = "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>."
parser = BrainfuckParser(code)
ast = parser.parse_program()


# class BrainfuckParser:
#     def __init__(self, code):
#         self.code = code
#         self.current_position = 0
#         self.production_rules = {
#             "program": [["command", "program"], ["command"]],
#             # "loop": [["[", "program", "]"]],
#             "command": [[">"], ["<"], ["+"], ["-"], ["."], [","]],
#         }

#     def parse(self, rule, token_idx):
#         if token_idx == len(self.code):
#             return None, token_idx
#         token = self.code[token_idx]
#         valid_nodes = []
#         for rule2 in self.production_rules[rule]:
#             match = True
#             idx = token_idx
#             node = BrainFuckNode(rule)
#             for s_rule in rule2:
#                 if is_terminal(s_rule):
#                     if token == s_rule:
#                         idx += 1
#                         node.add_child(BrainFuckNode(token))
#                         match = True
#                     else:
#                         match = False

#                 else:
#                     snode, idx = self.parse(s_rule, idx)
#                     if snode:
#                         match = True
#                         node.add_child(snode)
#                     else:
#                         match = False
#             if match:
#                 return node, idx

#     def execute(self):
#         self.parse("program", 0)


# def print_tree(node, level=0):
#     print("  " * level + node.value)
#     print(node.children[0].children[0])


# # Example usage:
# if __name__ == "__main__":
#     code = "-"
#     parser = BrainfuckParser(code)
#     if parser.execute():
#         print(f"The Brainfuck code '{code}' is valid.")
#         print_tree(parser.execute())
#     else:
#         print(f"The Brainfuck code '{code}' is not valid.")


# def test_parser():
#     tokens = ["+", "-"]
#     parser = BrainfuckParser(tokens)
#     parse_tree = parser.execute()
#     print(parse_tree)
#     print("  aqwe")
#     print_tree(parse_tree)
